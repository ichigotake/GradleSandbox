/**
 * buiild.gradle もしくは build.gradle が利用する ファイルを更新したら
 * 「Sync project with gradle files」 しましょう
 */

apply plugin: 'android'

// 外部ファイル読み込み
apply from: 'util.gradle'

repositories {
    // 野良Mavenレポジトリ
    maven { url 'https://raw.github.com/ichigotake/ColorfulSweets/develop/repository' }
}

dependencies {
    // サポートライブラリを利用する場合は、SDKマネージャから「Android Support Library」をインストールしておく
    compile 'com.android.support:appcompat-v7:+'
    // 野良Mavenレポジトリ
    compile 'net.ichigotake.colorfulsweets:ColorfulSweets:0.0.7'
    // settings.gradleの別プロジェクトを読み込む
    compile project(':lib')
}

android {
    compileSdkVersion 19
    buildToolsVersion "19.0.1"

    // 全ての BuildVariants に適用されるベースの設定(個別に上書きも可能)
    defaultConfig {
        minSdkVersion 11
        targetSdkVersion 19

        // gradle-android-utils: readVersion()
        def version = readVersion(file("VERSION"))
        versionCode version.toVersionCode()
        versionName version.toVersionName()
    }

    // 署名ビルド
    signingConfigs {
        release {
            storeFile file(project.properties.storeFile)
            storePassword project.properties.storePassword
            keyAlias project.properties.storeAlias
            keyPassword project.properties.keyPassword
        }
    }

    /**
     * buildTypeとの使い分けとして、ソフトウェア的な振り分けに使われる風潮がある?(あまり文化はわかっていない
     */
    productFlavors {
        free {
            packageName "com.example.app.free"
        }

        pro {
            packageName "com.example.app.pro"
        }
    }

    /**
     * ビルドの種類。括弧内の環境は一例
     * productFlavorとの使い分けとして、ビルド方法やapkのアップロード先の振り分けに使われる風潮がある?(あまり文化はわかっていない
     */
    buildTypes {

        // 本番(Playストア)
        release {
            debuggable false
            runProguard false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
            signingConfig signingConfigs.release
        }

        stage.initWith(release) // releaseを継承する
        stage {
        // ステージング(DeployGate)
            packageNameSuffix '.stage'
            versionNameSuffix '-stage'
        }

        // デバッグ(開発環境)
        debug {
            debuggable true
            runProguard false
            packageNameSuffix '.debug'
            versionNameSuffix '-debug'

            // ビルド時に BuildConfig クラスに定数が定義される
            // 引数の中身がそのまま Java のソースコード上に展開されるので、
            // String の場合はクオートも含まないとコンパイルエラーを起こす
            buildConfigField "String", "DEBUG_MESSAGE", "\"debugビルド専用ですよ\""
        }
    }


    // メタファイルが原因で同じパッケージが複数コンパイルされてコケる場合がある
    packagingOptions {
        exclude 'META-INF/DEPENDENCIES'
        exclude 'META-INF/NOTICE'
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/LICENSE.txt'
        exclude 'META-INF/NOTICE.txt'
        exclude 'META-INF/MANIFEST.MF'
    }

    // Lintチェック。ブロック内は公式ガイドラインからの引用
    lintOptions {
        // set to true to turn off analysis progress reporting by lint
        //quiet true
        // if true, stop the gradle build if errors are found
        abortOnError false
        // if true, only report errors
        //ignoreWarnings true
        // if true, emit full/absolute paths to files with errors (true by default)
        //absolutePaths true
        // if true, check all issues, including those that are off by default
        //checkAllWarnings true
        // if true, treat all warnings as errors
        //warningsAsErrors true
        // turn off checking the given issue id's
        //disable 'TypographyFractions','TypographyQuotes'
        // turn on the given issue id's
        //enable 'RtlHardcoded','RtlCompat', 'RtlEnabled'
        // check *only* the given issue id's
        //check 'NewApi', 'InlinedApi'
        // if true, don't include source code lines in the error output
        //noLines true
        // if true, show all locations for an error, do not truncate lists, etc.
        //showAll true
        // Fallback lint configuration (default severities, etc.)
        //lintConfig file("default-lint.xml")
        // if true, generate a text report of issues (false by default)
        //textReport true
        // location to write the output; can be a file or 'stdout'
        //textOutput 'stdout'
        // if true, generate an XML report for use by for example Jenkins
        //xmlReport false
        // file to write report to (if not specified, defaults to lint-results.xml)
        //xmlOutput file("lint-report.xml")
        // if true, generate an HTML report (with issue explanations, sourcecode, etc)
        //htmlReport true
        // optional path to report (default will be lint-results.html in the builddir)
        //htmlOutput file("lint-report.html")
    }
}

//debugビルド時にアプリアイコンをグレースケールにする
//gradle-android-utils: makeGrayscaleLauncherIcon
makeGrayscaleLauncherIcon(file("src/main"), "ic_launcher.png")

/**
 * 全ての BuildVariants でループを回す
 */
android.applicationVariants.all { variant ->
    /**
     * Map を Resource の XML 構造に変換してファイルに書き込む
     *
     * gradle-android-utils: writeResources(File, Map<String, String>)
     */
    def baseDir = new File("${buildDir}/").getParent();
    def resourceDir = new File(baseDir + "/src/${variant.name}/res/values")
    resourceDir.mkdirs()
    def resourceFile = new File(resourceDir, "_app.xml")

    writeResources(resourceFile, ["app_name": "MyApp" + variant.name.capitalize()])
}

/**
 * 全ての BuildTypes でループを回す
 */
android.buildTypes.all{theBuildType ->
    /**
     * Map を BuildConfig にセットする
     * android.applicationVariants.all のループ内でこの処理をやると、
     * 同じ BuildConfig 内に指定した Map が多重定義されるので注意
     *
     * プルリクを出してるところ。マージされるかな?
     * https://github.com/gfx/gradle-android-utils/pull/7
     */
    def buildConfigMap = [
            'APP_NAME': 'MyApp' + theBuildType.name.capitalize(),
            'EXTENSION_MIN_SDK_INT': 14,
            'API_SERVER_PRODUCTION': false,
    ]
    //util.gradleに入っているメソッド
    setBuildConfigField(theBuildType, buildConfigMap)
}

/**
 * カスタムタスク: generateManifest
 * BuildVariants 毎の AndroidManifest.xml を用意する
 */
task generateManifest << {
    android.applicationVariants.all { variant ->
        def baseDir = new File("${buildDir}/").getParent();

        /**
         * BuildVariant用のAndroidManifest.xmlを用意する
         */
        new File(baseDir + "/src/${variant.name}").mkdirs();
        def ns = new groovy.xml.Namespace("http://schemas.android.com/apk/res/android", "ns")
        def baseManifest = {
            def file = new File(baseDir + "/src/main/AndroidManifest.xml");
            return new XmlParser(false, true).parseText(file.getText())
        }()
        def basePackageName = baseManifest.'@package'
        def variantPackageName = {
            def name = variant.productFlavors.get(0).packageName
            if (variant.buildType.packageNameSuffix != null) {
                name += variant.buildType.packageNameSuffix
            }
            return name
        }()
        def variantManifestNode = new XmlParser(false, false).parseText(
                "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
                        "<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n" +
                        "    package=\"${variantPackageName}\" />"
        )

        // パッケージ名の差分を用意する
        for (def node in baseManifest.children()) {
            switch (node.name()) {
                case 'permission':
                case 'uses-permission':
                    def name = node.attributes()[ns.'name']
                    node.attributes()[ns.'name'] = name.replace(basePackageName, variantPackageName)
                    variantManifestNode.append(node)
                    break

            }
        }

        // "app/${variant.name}/AndroidManifest.xml" へ書き込む
        def variantManifestFile = new File(baseDir + "/src/${variant.name}/AndroidManifest.xml")
        def writer = new FileWriter(variantManifestFile)
        def printer = new XmlNodePrinter(new PrintWriter(writer))
        printer.setPreserveWhitespace(true)
        printer.print(variantManifestNode)
    }
}
